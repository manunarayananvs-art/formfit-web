<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FormFit - Private Image Compressor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background-color: #f8f9fa; font-family: 'Segoe UI', sans-serif; }
        .drop-zone { border: 2px dashed #0d6efd; border-radius: 10px; padding: 40px; text-align: center; background: white; cursor: pointer; transition: 0.3s; }
        .drop-zone:hover { background-color: #e9ecef; }
        .preview-img { max-width: 100%; height: auto; border-radius: 5px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .badge-safe { background-color: #d1e7dd; color: #0f5132; padding: 5px 10px; border-radius: 20px; font-size: 0.8em; }
    </style>
</head>
<body>

<div class="container mt-5" style="max-width: 600px;">
    <div class="text-center mb-4">
        <h1>üñºÔ∏è FormFit</h1>
        <p class="text-muted">Compress images for forms securely.</p>
        <span class="badge-safe">üîí Local Processing (Images never leave your device)</span>
    </div>

    <div class="drop-zone mb-4" onclick="document.getElementById('imageInput').click()">
        <h4>Tap to Select Image</h4>
        <p class="text-muted small">Supports JPG, PNG, WEBP</p>
        <input type="file" id="imageInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
    </div>

    <div id="controlsArea" class="card p-3 shadow-sm" style="display: none;">
        <div class="row">
            <div class="col-6 text-center">
                <h6>Original</h6>
                <p id="originalSize" class="small text-danger"></p>
            </div>
            <div class="col-6 text-center">
                <h6>Compressed</h6>
                <p id="compressedSize" class="small text-success">Waiting...</p>
            </div>
        </div>

        <label class="form-label fw-bold mt-2">Target Size (KB)</label>
        <div class="d-flex gap-2 mb-3">
            <button class="btn btn-outline-secondary btn-sm" onclick="setTarget(20)">20KB (Sign)</button>
            <button class="btn btn-outline-secondary btn-sm" onclick="setTarget(50)">50KB (Photo)</button>
            <button class="btn btn-outline-secondary btn-sm" onclick="setTarget(100)">100KB (Doc)</button>
        </div>
        
        <input type="range" class="form-range" id="sizeSlider" min="10" max="500" step="10" value="50" oninput="updateSliderVal(this.value)">
        <p class="text-center small">Target: <span id="sliderValue">50</span> KB</p>

        <button class="btn btn-primary w-100 mt-2" onclick="compressImage()">Compress Now</button>
        
        <div id="downloadArea" class="mt-3 text-center" style="display: none;">
            <p id="qualityInfo" class="small text-muted mb-2"></p> <a id="downloadLink" href="#" download="formfit_compressed.jpg" class="btn btn-success w-100">‚¨áÔ∏è Download Image</a>
        </div>
    </div>
</div>

<script>
    let originalFile = null;

    function handleImageUpload(event) {
        originalFile = event.target.files[0];
        if (!originalFile) return;

        // Show UI
        document.getElementById('controlsArea').style.display = 'block';
        document.getElementById('originalSize').innerText = (originalFile.size / 1024).toFixed(2) + " KB";
        document.getElementById('downloadArea').style.display = 'none';
        
        // Auto compress with default logic initially
        compressImage();
    }

    function setTarget(kb) {
        document.getElementById('sizeSlider').value = kb;
        updateSliderVal(kb);
        compressImage();
    }

    function updateSliderVal(val) {
        document.getElementById('sliderValue').innerText = val;
    }

    async function compressImage() {
        if (!originalFile) return;

        const targetKB = document.getElementById('sizeSlider').value;
        const targetBytes = targetKB * 1024; // Convert KB to Bytes

        document.getElementById('compressedSize').innerText = "Processing...";
        document.getElementById('downloadArea').style.display = 'none';

        try {
            // 1. Create Bitmap from file
            const bitmap = await createImageBitmap(originalFile);
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);

            // 2. Run Smart Recursive Compression
            const compressedBlob = await compressRecursive(canvas, targetBytes);
            
            // 3. Update UI
            const finalSizeKB = (compressedBlob.size / 1024).toFixed(2);
            document.getElementById('compressedSize').innerText = finalSizeKB + " KB";
            
            // Quality Stats Display
            const qPercent = (compressedBlob.quality * 100).toFixed(0);
            document.getElementById('qualityInfo').innerText = 
                `Quality: ${qPercent}% | Res: ${compressedBlob.width}x${compressedBlob.height}`;

            const downloadLink = document.getElementById('downloadLink');
            downloadLink.href = URL.createObjectURL(compressedBlob);
            document.getElementById('downloadArea').style.display = 'block';

        } catch (error) {
            console.error(error);
            alert("Could not compress image: " + error.message);
        }
    }

    /**
     * SMART COMPRESSION ALGORITHM
     * 1. Binary searches for best JPG quality.
     * 2. If quality drops below 15% to hit target, it resizes the image instead.
     */
    async function compressRecursive(canvas, targetSize) {
        let min = 0.0;
        let max = 1.0;
        let bestBlob = null;
        let bestQuality = 0;

        // Pass 1: Binary Search for Quality (Try 50%, then 75%, etc.)
        for (let i = 0; i < 8; i++) {
            const mid = (min + max) / 2;
            const blob = await getCanvasBlob(canvas, mid);
            
            if (blob.size <= targetSize) {
                bestBlob = blob;
                bestQuality = mid;
                min = mid; // Try higher quality
            } else {
                max = mid; // Needs lower quality
            }
        }

        // Pass 2: Check if result is acceptable
        // If we found a blob that fits AND quality is > 15%, or image is already tiny, return it.
        if ((bestBlob && bestQuality > 0.15) || canvas.width < 400) {
            bestBlob.quality = bestQuality;
            bestBlob.width = canvas.width;
            bestBlob.height = canvas.height;
            return bestBlob;
        }

        // Pass 3: Fallback - Resize Image
        // If quality is trash (e.g., 5%), scale down image dimensions by 25% and try again.
        const newCanvas = document.createElement('canvas');
        const scaleFactor = 0.75;
        newCanvas.width = Math.floor(canvas.width * scaleFactor);
        newCanvas.height = Math.floor(canvas.height * scaleFactor);
        const ctx = newCanvas.getContext('2d');
        ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);

        return await compressRecursive(newCanvas, targetSize);
    }

    function getCanvasBlob(canvas, quality) {
        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/jpeg', quality);
        });
    }
</script>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
  // Firebase configuration goes here
</script>

</body>
</html>
