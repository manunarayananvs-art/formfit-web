<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Image Compression</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        .preview { max-width: 100%; margin-top: 10px; border: 1px solid #ccc; }
        .stats { margin-top: 10px; font-size: 0.9em; color: #555; }
    </style>
</head>
<body>

<div class="container">
    <h2>Smart Compress to Target Size</h2>
    
    <label>Target Size (KB): <input type="number" id="targetSize" value="200"></label>
    <br><br>
    <input type="file" id="imageInput" accept="image/*">
    
    <div id="status" style="margin-top:10px; font-weight:bold;"></div>

    <div class="stats" id="beforeStats"></div>
    <div class="stats" id="afterStats"></div>
    <img id="compressedImage" class="preview" style="display:none;">
    
    <br>
    <a id="downloadLink" style="display:none;">Download Compressed Image</a>
</div>

<script>
    const input = document.getElementById('imageInput');
    const targetSizeInput = document.getElementById('targetSize');
    const status = document.getElementById('status');

    input.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // Reset UI
        status.textContent = "Compressing... please wait.";
        document.getElementById('downloadLink').style.display = 'none';
        
        // Convert KB to Bytes
        const MAX_SIZE = targetSizeInput.value * 1024; 
        
        document.getElementById('beforeStats').textContent = `Original: ${(file.size / 1024).toFixed(2)} KB`;

        try {
            // We start with the original dimensions
            const bitmap = await createImageBitmap(file);
            const canvas = document.createElement('canvas');
            canvas.width = bitmap.width;
            canvas.height = bitmap.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(bitmap, 0, 0);

            // Start the smart compression process
            const compressedBlob = await compressRecursive(canvas, MAX_SIZE);
            
            // --- UI Update Section ---
            const url = URL.createObjectURL(compressedBlob);
            const img = document.getElementById('compressedImage');
            img.src = url;
            img.style.display = 'block';
            
            document.getElementById('afterStats').innerHTML = `
                Compressed: <b>${(compressedBlob.size / 1024).toFixed(2)} KB</b> 
                (Quality: ${(compressedBlob.quality * 100).toFixed(0)}%, 
                 Res: ${compressedBlob.width}x${compressedBlob.height})`;
            
            const link = document.getElementById('downloadLink');
            link.href = url;
            link.download = "compressed-image.jpg";
            link.style.display = 'block';
            link.textContent = "Download Compressed Image";
            
            status.textContent = "Done!";
        } catch (error) {
            console.error(error);
            status.textContent = "Error: " + error.message;
        }
    });

    /**
     * Recursive function that tries to compress by quality first.
     * If quality drops too low (blurriness), it resizes the canvas and retries.
     */
    async function compressRecursive(canvas, targetSize) {
        // 1. Binary search for best quality at current resolution
        let min = 0.0;
        let max = 1.0;
        let bestBlob = null;
        let bestQuality = 0;

        // Try to find the highest quality that fits
        for (let i = 0; i < 10; i++) { // 10 iterations is enough precision
            const mid = (min + max) / 2;
            const blob = await getCanvasBlob(canvas, mid);
            
            if (blob.size <= targetSize) {
                bestBlob = blob;
                bestQuality = mid;
                min = mid; // Try for higher quality
            } else {
                max = mid; // Needs lower quality
            }
        }

        // 2. Decision Gate:
        // If we found a valid blob and the quality isn't "garbage" (e.g. > 0.1), return it.
        // OR if the canvas is already very small (e.g. < 300px), we just return what we have to stop infinite loops.
        if ((bestBlob && bestQuality > 0.15) || canvas.width < 300) {
            // Attach metadata for the UI to display
            bestBlob.quality = bestQuality;
            bestBlob.width = canvas.width;
            bestBlob.height = canvas.height;
            return bestBlob;
        }

        // 3. Resize Strategy (If quality is too low or file still too big):
        // If we reached here, the file is likely still too big or looks bad at current resolution.
        // Scale down by 25% and recurse.
        const newCanvas = document.createElement('canvas');
        const scaleFactor = 0.75;
        newCanvas.width = canvas.width * scaleFactor;
        newCanvas.height = canvas.height * scaleFactor;
        
        const ctx = newCanvas.getContext('2d');
        // Draw the previous canvas onto the smaller one
        ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);

        // Recurse with the smaller canvas
        return await compressRecursive(newCanvas, targetSize);
    }

    // Helper: Promisify canvas.toBlob
    function getCanvasBlob(canvas, quality) {
        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/jpeg', quality);
        });
    }
</script>

</body>
</html>
