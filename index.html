<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Image Compression</title>
    <style>
        body { font-family: sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        .preview { max-width: 100%; margin-top: 10px; border: 1px solid #ccc; }
        .stats { margin-top: 10px; font-size: 0.9em; color: #555; }
    </style>
</head>
<body>

<div class="container">
    <h2>Smart Compress to Target Size</h2>
    
    <label>Target Size (KB): <input type="number" id="targetSize" value="200"></label>
    <br><br>
    <input type="file" id="imageInput" accept="image/*">
    
    <div id="status" style="margin-top:10px; font-weight:bold;"></div>

    <div class="stats" id="beforeStats"></div>
    <div class="stats" id="afterStats"></div>
    <img id="compressedImage" class="preview" style="display:none;">
    
    <br>
    <a id="downloadLink" style="display:none;">Download Compressed Image</a>
</div>

<script>
    const input = document.getElementById('imageInput');
    const targetSizeInput = document.getElementById('targetSize');
    const status = document.getElementById('status');

    input.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // Convert KB to Bytes
        const MAX_SIZE = targetSizeInput.value * 1024; 
        
        status.textContent = "Compressing... please wait.";
        document.getElementById('beforeStats').textContent = `Original: ${(file.size / 1024).toFixed(2)} KB`;

        try {
            const compressedBlob = await compressToTargetSize(file, MAX_SIZE);
            
            // Display Result
            const url = URL.createObjectURL(compressedBlob);
            const img = document.getElementById('compressedImage');
            img.src = url;
            img.style.display = 'block';
            
            document.getElementById('afterStats').innerHTML = `
                Compressed: <b>${(compressedBlob.size / 1024).toFixed(2)} KB</b> 
                (Quality used: ${compressedBlob.qualityUsed})`; // Custom property for display
            
            const link = document.getElementById('downloadLink');
            link.href = url;
            link.download = "compressed-image.jpg";
            link.style.display = 'block';
            link.textContent = "Download Compressed Image";
            
            status.textContent = "Done!";
        } catch (error) {
            status.textContent = "Error: " + error.message;
        }
    });

    // Core Logic
    async function compressToTargetSize(file, targetSize) {
        // Load image to get dimensions
        const bitmap = await createImageBitmap(file);
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = bitmap.width;
        let height = bitmap.height;
        
        // Initial Draw
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(bitmap, 0, 0, width, height);

        // 1. Binary Search Strategy for Quality
        let min = 0;
        let max = 1;
        let bestBlob = null;
        let bestQuality = 0;
        
        // Attempt compression loop
        // We limit iterations to prevent infinite loops (approx 10 steps covers 0.00 to 1.00 precision)
        for (let i = 0; i < 15; i++) {
            const mid = (min + max) / 2;
            const blob = await getCanvasBlob(canvas, mid);
            
            if (blob.size <= targetSize) {
                // It fits! Try to increase quality to see if we can get closer to limit
                bestBlob = blob;
                bestQuality = mid;
                min = mid; 
            } else {
                // Too big, decrease quality
                max = mid; 
            }
        }

        // 2. FALLBACK: Smart Resizing
        // If even at extremely low quality (e.g. 0.1) the file is still too big,
        // we must resize the dimensions (scale down) rather than creating a blocky mess.
        if (!bestBlob || (bestBlob.size > targetSize)) {
            const scaleFactor = 0.7; // Reduce size by 30% each step
            canvas.width = canvas.width * scaleFactor;
            canvas.height = canvas.height * scaleFactor;
            
            // Redraw at new size
            ctx.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
            
            // Recursively try again with smaller dimensions
            return compressToTargetSize(await getCanvasBlob(canvas, 1), targetSize);
        }

        // Attach the final quality used for debugging/display
        bestBlob.qualityUsed = bestQuality.toFixed(2);
        return bestBlob;
    }

    // Helper to wrap canvas.toBlob in a Promise
    function getCanvasBlob(canvas, quality) {
        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/jpeg', quality);
        });
    }
</script>

</body>
</html>
